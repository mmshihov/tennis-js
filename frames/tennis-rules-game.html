<html>
<head>
    <meta charset="utf-8">
    <style>
        .sCourt {
            background-color:orange;
            position:relative;
        }
        .sField {
            background-color:blue;
            position:absolute;
        }
        .sLine {
            background-color:white;
            position:absolute;
        }
        .sNet {
            background-color:gray;
            position:absolute;
        }
        .sBall {
            background-color:yellow;
            -webkit-border-radius:50%;
            -moz-border-radius:50%;
            border-radius:50%;
            position:absolute;
        }
        .sBallShadow {
            background-color:black;
            -webkit-border-radius:50%/50%;
            -moz-border-radius:50%/50%;
            border-radius:50%/50%;
            position:absolute;
        }
        .sMyPlayer {
            -webkit-border-radius:50%;
            -moz-border-radius:50%;
            border-radius:50%;
            position:absolute;
            background-color:green;
        }
        .sHisPlayer {
            -webkit-border-radius:50%;
            -moz-border-radius:50%;
            border-radius:50%;
            position:absolute;
            background-color:gray;
        }
        .sFlash {
            background-color:red;
            -webkit-border-radius:50%;
            -moz-border-radius:50%;
            border-radius:50%;
            position:absolute;
        }
    </style>
</head>
<body>
    <div id="mCourt" class="sCourt">
        <div id="mField" class="sField"></div>

        <div id="mLineLeftOuter" class="sLine"></div>
        <div id="mLineRightOuter" class="sLine"></div>
        <div id="mLineLeftInner" class="sLine"></div>
        <div id="mLineRightInner" class="sLine"></div>
        <div id="mLineTopOuter" class="sLine"></div>
        <div id="mLineBottomOuter" class="sLine"></div>
        <div id="mLineTopInner" class="sLine"></div>
        <div id="mLineBottomInner" class="sLine"></div>
        <div id="mLineCentral" class="sLine"></div>
        <div id="mLineTopMark" class="sLine"></div>
        <div id="mLineBottomMark" class="sLine"></div>
        
        <div id="mNet" class="sNet"></div>

        <div id="mMyPlayer" class="sMyPlayer"></div>
        <div id="mHisPlayer" class="sHisPlayer"></div>
        
        <div id="mBallShadow" class="sBallShadow"></div>
        <div id="mBall" class="sBall"></div>
        <div id="mFlash" class="sFlash"></div>
    <div>
    <input type="button" value="Победить" onclick="onWinButtonClick()">
    <script>
        var PAIR_FIELD_WIDTH     = 10.973; //metres
        var SINGLE_FIELD_WIDTH   = 8.23; 
        var FIELD_LENGTH         = 11.89;
        var SERVICE_FIELD_LENGTH = 6.40;
        var COURT_LENGTH         = (2 * FIELD_LENGTH) + 6;
        var COURT_WIDTH          = PAIR_FIELD_WIDTH + 6;
        var NET_WIDTH            = PAIR_FIELD_WIDTH + 2 * 0.914;
        var LINE_WIDTH           = 0.25;
        var MARK_LENGTH          = LINE_WIDTH * 2;
        
        var BALL_RADIUS          = 1.5 * LINE_WIDTH;
        var FLASH_RADIUS         = BALL_RADIUS * 0.8;
        var PLAYER_HEIGHT        = BALL_RADIUS * 2;
        var PLAYER_WIDTH         = PLAYER_HEIGHT * 2;

        var VIEW_WIDTH = 300; //pixels
        
        //типы действий на площадке
        var SERVICE_ID    = 1;  //подача
        var BOUND_SHOT_ID = 2;  //удачно отбиваем мяч с отскока
        var BOUND_LOSS_ID = 4;  //не отбиваем мяч с отскока
        var NET_ID        = 8;  //в сетку
        var OUT_ID        = 16; //в аут
        var PAUSE_ID      = 32; //пауза

        //miliseconds
        var SERVICE_DURATION = 1500;
        var NET_DURATION     = 1000;
        var OUT_DURATION     = 1700;
        var IN_DURATION      = 1200;
        var PAUSE_DURATION   = 1000;
        
        var THIRD_POINT_SCALE = 0.25;
        
        var GAME_OUT_POINTS;
        var GAME_IN_POINTS;
        var SERVICE_FROM_POINTS;
        var SERVICE_IN_POINTS;
        var SERVICE_OUT_POINTS;
        var NET_POINTS;
        
        //globals
        var animationStartTime;
        var pointAnimationFrames;
        
        function playerDivFor(player) {
            player = player % 2;
            return (player == 0) ? mMyPlayer : mHisPlayer;
        }
        
        function lenToView(len) {
            return (len * VIEW_WIDTH) / COURT_WIDTH;
        }
        
        function xToViewLeft(x) {
            return ((x + COURT_WIDTH / 2) * VIEW_WIDTH) / COURT_WIDTH;
        }
        
        function yToViewTop(y) {
            return ((y + COURT_LENGTH / 2) * VIEW_WIDTH) / COURT_WIDTH;
        }
        
        function drawVerticalLine(lineDiv, x, y1, y2) { //assert: y2>y1
            var lineWidth = (LINE_WIDTH * VIEW_WIDTH) / COURT_WIDTH;
        
            lineDiv.style.width  = lineWidth;
            lineDiv.style.height = (yToViewTop(y2) - yToViewTop(y1)) + lineWidth;
            
            lineDiv.style.top = yToViewTop(y1) - lineWidth/2;
            lineDiv.style.left = xToViewLeft(x) - lineWidth/2;
        }
        
        function drawHorizontalLine(lineDiv, y, x1, x2) { //assert: x2>x1
            var lineWidth = (LINE_WIDTH * VIEW_WIDTH) / COURT_WIDTH;
        
            lineDiv.style.width  = (xToViewLeft(x2) - xToViewLeft(x1)) + lineWidth;
            lineDiv.style.height = lineWidth;
            
            lineDiv.style.top = yToViewTop(y) - lineWidth/2;
            lineDiv.style.left = xToViewLeft(x1) - lineWidth/2;
        }
        
        function initBall() {
            mBall.style.height = 2 * lenToView(BALL_RADIUS);
            mBall.style.width = 2 * lenToView(BALL_RADIUS);
            
            mBallShadow.style.height = 2 * lenToView(BALL_RADIUS);
            mBallShadow.style.width = 2 * lenToView(BALL_RADIUS);
            
            moveBallTo(0,0);
            moveBallShadowTo(0,0);
        }
        
        function initFlash() {
            mFlash.style.height = 2 * lenToView(FLASH_RADIUS);
            mFlash.style.width = 2 * lenToView(FLASH_RADIUS);
        }
        
        function initPlayer(playerDiv) {
            playerDiv.style.height = lenToView(PLAYER_HEIGHT);
            playerDiv.style.width = lenToView(PLAYER_WIDTH);
        }
        
        function initPlayers() {
            initPlayer(mMyPlayer);
            movePlayerTo(mMyPlayer, 0, FIELD_LENGTH);
            
            initPlayer(mHisPlayer);
            movePlayerTo(mHisPlayer, 0, -FIELD_LENGTH);
        }
        
        function initGameOutPoints() {
            GAME_OUT_POINTS = [];

            GAME_OUT_POINTS[0] = {};
            GAME_OUT_POINTS[0].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            GAME_OUT_POINTS[0].y = SERVICE_FIELD_LENGTH/2;

            GAME_OUT_POINTS[1] = {};
            GAME_OUT_POINTS[1].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            GAME_OUT_POINTS[1].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_OUT_POINTS[2] = {};
            GAME_OUT_POINTS[2].x = (PAIR_FIELD_WIDTH + COURT_WIDTH)/4;
            GAME_OUT_POINTS[2].y = SERVICE_FIELD_LENGTH/2;

            GAME_OUT_POINTS[3] = {};
            GAME_OUT_POINTS[3].x = (PAIR_FIELD_WIDTH + COURT_WIDTH)/4;
            GAME_OUT_POINTS[3].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_OUT_POINTS[4] = {};
            GAME_OUT_POINTS[4].x = SINGLE_FIELD_WIDTH/12;
            GAME_OUT_POINTS[4].y = (2*FIELD_LENGTH + COURT_LENGTH)/4;

            GAME_OUT_POINTS[5] = {};
            GAME_OUT_POINTS[5].x = SINGLE_FIELD_WIDTH/4;
            GAME_OUT_POINTS[5].y = (2*FIELD_LENGTH + COURT_LENGTH)/4;

            GAME_OUT_POINTS[6] = {};
            GAME_OUT_POINTS[6].x = SINGLE_FIELD_WIDTH*5/12;
            GAME_OUT_POINTS[6].y = (2*FIELD_LENGTH + COURT_LENGTH)/4;
        }
        
        function initGameInPoints() {
            GAME_IN_POINTS = [];
            
            GAME_IN_POINTS[0] = {};
            GAME_IN_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            GAME_IN_POINTS[0].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_IN_POINTS[1] = {};
            GAME_IN_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            GAME_IN_POINTS[1].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_IN_POINTS[2] = {};
            GAME_IN_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            GAME_IN_POINTS[2].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;
            
            GAME_IN_POINTS[3] = {};
            GAME_IN_POINTS[3].x = SINGLE_FIELD_WIDTH/12;
            GAME_IN_POINTS[3].y = SERVICE_FIELD_LENGTH/2;

            GAME_IN_POINTS[4] = {};
            GAME_IN_POINTS[4].x = SINGLE_FIELD_WIDTH/4;
            GAME_IN_POINTS[4].y = SERVICE_FIELD_LENGTH/2;

            GAME_IN_POINTS[5] = {};
            GAME_IN_POINTS[5].x = SINGLE_FIELD_WIDTH*5/12;
            GAME_IN_POINTS[5].y = SERVICE_FIELD_LENGTH/2;
        }
        
        function initServiceFromPoints() {
            SERVICE_FROM_POINTS = [];
            
            SERVICE_FROM_POINTS[0] = {};
            SERVICE_FROM_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            SERVICE_FROM_POINTS[0].y = FIELD_LENGTH + PLAYER_HEIGHT;
            
            SERVICE_FROM_POINTS[1] = {};
            SERVICE_FROM_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            SERVICE_FROM_POINTS[1].y = FIELD_LENGTH + PLAYER_HEIGHT;

            SERVICE_FROM_POINTS[2] = {};
            SERVICE_FROM_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            SERVICE_FROM_POINTS[2].y = FIELD_LENGTH + PLAYER_HEIGHT;
        }
        
        function initServiceOutPoints() {
            SERVICE_OUT_POINTS = [];
            
            SERVICE_OUT_POINTS[0] = {};
            SERVICE_OUT_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            SERVICE_OUT_POINTS[0].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            SERVICE_OUT_POINTS[1] = {};
            SERVICE_OUT_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            SERVICE_OUT_POINTS[1].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            SERVICE_OUT_POINTS[2] = {};
            SERVICE_OUT_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            SERVICE_OUT_POINTS[2].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            SERVICE_OUT_POINTS[3] = {};
            SERVICE_OUT_POINTS[3].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            SERVICE_OUT_POINTS[3].y = SERVICE_FIELD_LENGTH/2;

            SERVICE_OUT_POINTS[4] = {};
            SERVICE_OUT_POINTS[4].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            SERVICE_OUT_POINTS[4].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;
        }
        
        function initNetPoints() {
            NET_POINTS = [];
            
            NET_POINTS[0] = {};
            NET_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            NET_POINTS[0].y = BALL_RADIUS;

            NET_POINTS[1] = {};
            NET_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            NET_POINTS[1].y = BALL_RADIUS;

            NET_POINTS[2] = {};
            NET_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            NET_POINTS[2].y = BALL_RADIUS;
        }

        function initServiceInPoints() {
            SERVICE_IN_POINTS = [];
            
            SERVICE_IN_POINTS[0] = {};
            SERVICE_IN_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            SERVICE_IN_POINTS[0].y = SERVICE_FIELD_LENGTH - 2*BALL_RADIUS;

            SERVICE_IN_POINTS[1] = {};
            SERVICE_IN_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            SERVICE_IN_POINTS[1].y = SERVICE_FIELD_LENGTH - 2*BALL_RADIUS;

            SERVICE_IN_POINTS[2] = {};
            SERVICE_IN_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            SERVICE_IN_POINTS[2].y = SERVICE_FIELD_LENGTH - 2*BALL_RADIUS;
        }
        
        function initPoints() {
            initGameOutPoints();
            initGameInPoints();
            initServiceFromPoints();
            initServiceInPoints();
            initServiceOutPoints();
            initNetPoints();
        }
        
        function initCourt() {
            mCourt.style.width  = VIEW_WIDTH;
            mCourt.style.height = lenToView(COURT_LENGTH);
            
            mField.style.width = lenToView(PAIR_FIELD_WIDTH);
            mField.style.height = lenToView(2 * FIELD_LENGTH);
            
            mField.style.top = yToViewTop(-FIELD_LENGTH);
            mField.style.left = xToViewLeft(-PAIR_FIELD_WIDTH/2);
            
            drawVerticalLine(mLineLeftOuter, -PAIR_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);
            drawVerticalLine(mLineRightOuter, PAIR_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);

            drawVerticalLine(mLineLeftInner, -SINGLE_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);
            drawVerticalLine(mLineRightInner, SINGLE_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);

            drawVerticalLine(mLineCentral, 0, -SERVICE_FIELD_LENGTH, SERVICE_FIELD_LENGTH);

            drawVerticalLine(mLineTopMark, 0, -FIELD_LENGTH, -FIELD_LENGTH + MARK_LENGTH);
            drawVerticalLine(mLineBottomMark, 0, FIELD_LENGTH - MARK_LENGTH, FIELD_LENGTH);
            
            drawHorizontalLine(mLineTopOuter, -FIELD_LENGTH, -PAIR_FIELD_WIDTH/2, PAIR_FIELD_WIDTH/2);
            drawHorizontalLine(mLineBottomOuter,  FIELD_LENGTH, -PAIR_FIELD_WIDTH/2, PAIR_FIELD_WIDTH/2);

            drawHorizontalLine(mLineTopInner, -SERVICE_FIELD_LENGTH, -SINGLE_FIELD_WIDTH/2, SINGLE_FIELD_WIDTH/2);
            drawHorizontalLine(mLineBottomInner, SERVICE_FIELD_LENGTH, -SINGLE_FIELD_WIDTH/2, SINGLE_FIELD_WIDTH/2);

            drawHorizontalLine(mNet, 0, -NET_WIDTH/2, NET_WIDTH/2);
            
            initBall();
            initFlash();
            initPlayers();
            initPoints();
        } 
        
        function movePlayerTo(playerDiv, x, y) {
            playerDiv.style.left = xToViewLeft(x) - lenToView(PLAYER_WIDTH/2);
            playerDiv.style.top  = yToViewTop(y) - lenToView(PLAYER_HEIGHT/2);
        }
        
        function moveBallTo(x, y) {
            mBall.style.left = xToViewLeft(x) - lenToView(BALL_RADIUS);
            mBall.style.top  = yToViewTop(y) - lenToView(BALL_RADIUS);
        }
        
        function moveBallShadowTo(x, y) {
            mBallShadow.style.left = xToViewLeft(x) - lenToView(BALL_RADIUS);
            mBallShadow.style.top  = yToViewTop(y) - lenToView(BALL_RADIUS);
        }

        function setFlashVisible(isVisible) {
            if (isVisible) {
                mFlash.style.display = 'block';
            } else {
                mFlash.style.display = 'none';
            }
        }
        
        function moveFlashTo(x, y) {
            mFlash.style.left = xToViewLeft(x) - lenToView(FLASH_RADIUS);
            mFlash.style.top  = yToViewTop(y) - lenToView(FLASH_RADIUS);
            setFlashVisible(true);
        }
        
        function CCourtAction(actionType, duration, returnerId, returnerPoint, 
                              startBallPoint, boundBallPoint, afterBoundPart) {
            this.actionType = actionType;
            this.duration = duration;
            this.returnerId = returnerId;
            this.returnerPoint = returnerPoint;
            this.shotPoint = startBallPoint;
            this.boundPoint = boundBallPoint;
            this.afterBoundPart = afterBoundPart;
        }
        
        function makeService(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            return new CCourtAction(SERVICE_ID, duration, returnerId, returnerPoint,
                                    shotPoint, boundPoint, 
                                    1);
        }
        
        function makeBoundShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            var x1,y1,x2,y2;
            
            x1 = shotPoint.x;
            y1 = shotPoint.y;
            
            x2 = boundPoint.x;
            y2 = boundPoint.y;
            
            var t,x3,y3;
            
            t = 2 - 0.3;
            y3 = bezier2(t, y1, y2);
            x3 = bezier2(t, x1, x2);
            
            if ((y3 < -(COURT_LENGTH/2)) || ((COURT_LENGTH/2) < y3)) {
                t = 1 + 0.3;
                y3 = bezier2(t, y1, y2);
                if (y3 < -(COURT_LENGTH/2)) {
                    y3 = -(COURT_LENGTH/2);
                } else if (y3 > (COURT_LENGTH/2)) {
                    y3 = (COURT_LENGTH/2);
                }
                t = (y3-y1)/(y2-y1);
                x3 = bezier2(t,x1,x2);
            }
            
            if (x3 < -(COURT_WIDTH/2)) {
                x3 = -(COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            } else if (x3 > (COURT_WIDTH/2)) {
                x3 = (COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            }

            return new CCourtAction(BOUND_SHOT_ID, duration, returnerId, returnerPoint,
                                    shotPoint, boundPoint, 
                                    t-1);
        }

        function makeBoundLossShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            var x1,y1,x2,y2;
            
            x1 = shotPoint.x;
            y1 = shotPoint.y;
            
            x2 = boundPoint.x;
            y2 = boundPoint.y;
            
            var t, x3,y3;

            if (y1 < y2) {
                y3 = (COURT_LENGTH/2);
            } else {
                y3 = -(COURT_LENGTH/2);
            }
            
            t = (y3-y1)/(y2-y1);
            x3 = bezier2(t, x1, x2);
            
            if (x3 < -(COURT_WIDTH/2)) {
                x3 = -(COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            } else if (x3 > (COURT_WIDTH/2)) {
                x3 = (COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            }

            return new CCourtAction(BOUND_LOSS_ID, duration, returnerId, returnerPoint, 
                                    shotPoint, boundPoint, 
                                    t-1);
        }
        
        function makeNetShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            return new CCourtAction(NET_ID, duration, returnerId, returnerPoint, 
                                    shotPoint, boundPoint, 
                                    0.5);
        }
        
        function makeOutShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            var outShot = makeBoundLossShot(duration, returnerId, returnerPoint, shotPoint, boundPoint);
            outShot.actionType = OUT_ID;
            return outShot;
        }
        
        function makePause(duration) {
            return new CCourtAction(PAUSE_ID, duration, null/*returnerId*/, null/*returnerPoint*/, 
                                    null/*shotPoint*/, null/*boundPoint*/, 
                                    0.5);
        }
        
        function bezier2(t, a, b) {
            return (1-t)*a + t*b;
        }
        
        function bezier3(t, a, b, c) {
            return t*t*a + 2*(1-t)*t*b + (1-t)*(1-t)*c;
        }
        
        function getBezierThirdPoint(p1, p2) {
            var k = THIRD_POINT_SCALE;
            if (p1.x >= p2.x)
                k = -k;
            
            var p = {};
            p.x =  k*(p2.y - p1.y) + (p2.x - p1.x)/2 + p1.x;
            p.y = -k*(p2.x - p1.x) + (p2.y - p1.y)/2 + p1.y;
            return p;
        }
        
        function getCurrentFrame() {return pointAnimationFrames[0];}
        
        function animateService(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;
            
            movePlayerTo(playerDivFor(cmd.returnerId),   cmd.returnerPoint.x, cmd.returnerPoint.y);
            movePlayerTo(playerDivFor(1-cmd.returnerId), cmd.shotPoint.x, cmd.shotPoint.y);
            
            moveBallTo(cmd.shotPoint.x, cmd.shotPoint.y);
            moveBallShadowTo(cmd.shotPoint.x, cmd.shotPoint.y);
            
            if (Math.floor(timePassed*6/cmd.duration) % 2 == 0) {
                if (cmd.shotPoint.y > 0) {
                    moveFlashTo(cmd.shotPoint.x + BALL_RADIUS, cmd.shotPoint.y - BALL_RADIUS);
                } else {
                    moveFlashTo(cmd.shotPoint.x - BALL_RADIUS, cmd.shotPoint.y + BALL_RADIUS);
                }
            } else {
                setFlashVisible(false);
            }

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateService);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function animateBoundShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            var boundDuration = cmd.duration / (1 + cmd.afterBoundPart);
            
            if (timePassed <= boundDuration) {  //draw ball before bound part (parabolic curve)
                var thirdPoint = getBezierThirdPoint(cmd.shotPoint, cmd.boundPoint);
                
                var t = (boundDuration - timePassed) / boundDuration;
                setFlashVisible(false);
                moveBallTo(
                    bezier3(t, cmd.shotPoint.x, thirdPoint.x, cmd.boundPoint.x),
                    bezier3(t, cmd.shotPoint.y, thirdPoint.y, cmd.boundPoint.y));
            } else {                            //draw ball after bound 
                var t = 1 + (timePassed - boundDuration) / boundDuration;
                moveFlashTo(cmd.boundPoint.x, cmd.boundPoint.y);
                moveBallTo(
                    bezier2(t, cmd.shotPoint.x, cmd.boundPoint.x),
                    bezier2(t, cmd.shotPoint.y, cmd.boundPoint.y));
            }
                
            var t = timePassed/cmd.duration;
            
            moveBallShadowTo(
                bezier2(t, cmd.shotPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t, cmd.shotPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));
                    
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t, cmd.returnerPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t*t, cmd.returnerPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateBoundShot);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function animateBoundLossShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            var t = timePassed*(1 + cmd.afterBoundPart)/cmd.duration;
            var tFloor = Math.floor(t);
            
            var boundPoint1 = {};
            var boundPoint2 = {};
            
            boundPoint1.x = bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint1.y = bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y);

            boundPoint2.x = bezier2(tFloor + 1, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint2.y = bezier2(tFloor + 1, cmd.shotPoint.y, cmd.boundPoint.y);
            
            var thirdPoint = getBezierThirdPoint(boundPoint1, boundPoint2);
            moveBallTo(
                bezier3(t-tFloor, boundPoint2.x, thirdPoint.x, boundPoint1.x),
                bezier3(t-tFloor, boundPoint2.y, thirdPoint.y, boundPoint1.y));
            
            setFlashVisible(false);
            if (tFloor > 0) {
                moveFlashTo(
                    bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x),
                    bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y));
            }
            
            t = timePassed/cmd.duration;
            moveBallShadowTo(
                bezier2(t, cmd.shotPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t, cmd.shotPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));
                    
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t, cmd.returnerPoint.x, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t*t, cmd.returnerPoint.y, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.y, cmd.boundPoint.y)));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateBoundLossShot);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function animateNetShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;
            
            var boundDuration = cmd.duration / (1 + cmd.afterBoundPart);
            
            if (timePassed <= boundDuration) {  //draw ball before bound part (parabolic curve)
                var t = timePassed / boundDuration;
                setFlashVisible(false);
                var x = bezier2(t, cmd.shotPoint.x, cmd.boundPoint.x);
                var y = bezier2(t, cmd.shotPoint.y, cmd.boundPoint.y);
                moveBallTo(x, y);
                moveBallShadowTo(x,y);
            } else {                            //draw ball after bound 
                moveFlashTo(cmd.boundPoint.x, cmd.boundPoint.y);

                var t = (timePassed - boundDuration)/(boundDuration * cmd.afterBoundPart);
                var x;
                if (cmd.shotPoint.x > cmd.boundPoint.x) {
                    x = bezier2(t, cmd.boundPoint.x, cmd.boundPoint.x-BALL_RADIUS*2);
                } else {
                    x = bezier2(t, cmd.boundPoint.x, cmd.boundPoint.x+BALL_RADIUS*2);
                }
                
                moveBallTo(x, cmd.boundPoint.y);
                moveBallShadowTo(x, cmd.boundPoint.y);
            }
            
            var t = timePassed/(2 * cmd.duration);
            
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t, cmd.returnerPoint.x, cmd.boundPoint.x),
                bezier2(t*t, cmd.returnerPoint.y, cmd.boundPoint.y));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateNetShot);
            } else {
                nextPointAnimationFrame();
            }
        }

        function animateOutShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            var t = timePassed*(1 + cmd.afterBoundPart)/cmd.duration;
            var tFloor = Math.floor(t);
            
            var boundPoint1 = {};
            var boundPoint2 = {};
            
            boundPoint1.x = bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint1.y = bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y);

            boundPoint2.x = bezier2(tFloor + 1, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint2.y = bezier2(tFloor + 1, cmd.shotPoint.y, cmd.boundPoint.y);
            
            var thirdPoint = getBezierThirdPoint(boundPoint1, boundPoint2);
            moveBallTo(
                bezier3(t-tFloor, boundPoint2.x, thirdPoint.x, boundPoint1.x),
                bezier3(t-tFloor, boundPoint2.y, thirdPoint.y, boundPoint1.y));
            
            setFlashVisible(false);
            if (tFloor > 0) {
                moveFlashTo(
                    bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x),
                    bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y));
            }
            
            t = timePassed/cmd.duration;
            moveBallShadowTo(
                bezier2(t, cmd.shotPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t, cmd.shotPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));
                    
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t/2, cmd.returnerPoint.x, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t*t/2, cmd.returnerPoint.y, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.y, cmd.boundPoint.y)));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateOutShot);
            } else {
                nextPointAnimationFrame();
            }
        }

        function animatePause(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animatePause);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function nextPointAnimationFrame() {
            pointAnimationFrames.shift();
            startPointAnimation();
        }
        
        function startPointAnimation() {
            if (pointAnimationFrames[0] == null) {
                return;
            }
            
            animationStartTime = performance.now();
            switch(pointAnimationFrames[0].actionType) {
            case SERVICE_ID:    requestAnimationFrame(animateService); break;
            case BOUND_SHOT_ID: requestAnimationFrame(animateBoundShot); break;
            case BOUND_LOSS_ID: requestAnimationFrame(animateBoundLossShot); break;
            case NET_ID:        requestAnimationFrame(animateNetShot); break;
            case OUT_ID:        requestAnimationFrame(animateOutShot); break;
            case PAUSE_ID:      requestAnimationFrame(animatePause); break;
            }
        }
        
        function getRandomPointFrom(arr) {
            var point = arr[Math.floor(Math.random() * (arr.length))];

            var pointCopy = {};
            pointCopy.x = point.x;
            pointCopy.y = point.y;

            return pointCopy;
        }
        
        function getAndScaleRandomPointFrom(arr, xscale, yscale) {
            var point = getRandomPointFrom(arr);
            point.x = xscale * point.x;
            point.y = yscale * point.y;
            
            return point;
        }
        
        function getCurrentHalf() {
            return 1; //TODO: зависит от счета в гейме
        }
        
        function generateDoubleFaultFrames(serverId) {
            var half = getCurrentHalf();
            var side = 1;
            
            if ((serverId % 2) != 0) {
                side = -1;
                half = -half;
            }
            
            pointAnimationFrames = [];
            
            for (var i=0; i<2; i++) {
                var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
                var returnerPoint = {};
                returnerPoint.x = -shotPoint.x;
                returnerPoint.y = -shotPoint.y;
                
                generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side);
                
                if (i < 1) {
                    pointAnimationFrames.push(makePause(PAUSE_DURATION));
                }
            }
        }

        function generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side) {
            pointAnimationFrames.push(
                makeService(SERVICE_DURATION, 1-serverId, returnerPoint, shotPoint, shotPoint));
                
            if (Math.random() < 0.5) { //in out
                var outPoint = getAndScaleRandomPointFrom(SERVICE_OUT_POINTS, -half, -side);
                
                pointAnimationFrames.push(
                    makeOutShot(OUT_DURATION, 1-serverId, returnerPoint, shotPoint, outPoint));
            } else { //in net
                var netPoint = getAndScaleRandomPointFrom(NET_POINTS, -half, side);
                
                pointAnimationFrames.push(
                    makeNetShot(NET_DURATION, 1-serverId, returnerPoint, shotPoint, netPoint));
            }
        }
        
        function generateWinnerFrames(serverId, winnerId) {
            var half = getCurrentHalf();
            var side = 1;
            
            if ((serverId % 2) != 0) {
                side = -1;
                half = -half;
            }
            
            pointAnimationFrames = [];
            
            var gameShotCount = Math.floor(Math.random() * 4)*2; //odd!
            if (serverId != winnerId) {
                gameShotCount = gameShotCount + 1;
            }
            
            if (Math.random() < 0.3) {
                var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
                var returnerPoint = {};
                returnerPoint.x = -shotPoint.x;
                returnerPoint.y = -shotPoint.y;
                
                generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side);
                pointAnimationFrames.push(makePause(PAUSE_DURATION));
            }
            
            var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
            var returnerPoint = {};
            returnerPoint.x = -shotPoint.x;
            returnerPoint.y = -shotPoint.y;
            
            pointAnimationFrames.push(
                makeService(SERVICE_DURATION, 1-serverId, returnerPoint, shotPoint, shotPoint));
            
            for (var i=0; i<gameShotCount; i++) {
                var boundPoint = (i == 0) ? getAndScaleRandomPointFrom(SERVICE_IN_POINTS, -half, -side)
                                          : getAndScaleRandomPointFrom(GAME_IN_POINTS, -half, -side);
                var cmd = makeBoundShot(IN_DURATION, 1-serverId, returnerPoint, shotPoint, boundPoint);
                
                pointAnimationFrames.push(cmd);
                
                returnerPoint = {};
                returnerPoint.x = shotPoint.x;
                returnerPoint.y = shotPoint.y;
                
                shotPoint = {};
                shotPoint.x = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x);
                shotPoint.y = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y);
                
                side = -side;
                serverId = 1 - serverId;
                
                if (Math.random() < 0.5) {
                    half = -half;
                }
            }
            
            var boundPoint = getAndScaleRandomPointFrom(GAME_IN_POINTS, -half, -side);
            pointAnimationFrames.push(
                makeBoundLossShot(IN_DURATION, 1-serverId, returnerPoint, shotPoint, boundPoint));
        }
        
        function generateErrorFrames(serverId, winnerId) {
            var half = getCurrentHalf();
            var side = 1;
            
            if ((serverId % 2) != 0) {
                side = -1;
                half = -half;
            }
            
            pointAnimationFrames = [];
            
            var gameShotCount = Math.floor(Math.random() * 4)*2 + 1; 
            if (serverId != winnerId) {
                gameShotCount = gameShotCount + 1;
            }
            
            if (Math.random() < 0.3) {
                var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
                var returnerPoint = {};
                returnerPoint.x = -shotPoint.x;
                returnerPoint.y = -shotPoint.y;
                
                generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side);
                pointAnimationFrames.push(makePause(PAUSE_DURATION));
            }
            
            var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
            var returnerPoint = {};
            returnerPoint.x = -shotPoint.x;
            returnerPoint.y = -shotPoint.y;
            
            pointAnimationFrames.push(
                makeService(SERVICE_DURATION, 1-serverId, returnerPoint, shotPoint, shotPoint));
            
            for (var i=0; i<gameShotCount; i++) {
                var boundPoint = (i == 0) ? getAndScaleRandomPointFrom(SERVICE_IN_POINTS, -half, -side)
                                          : getAndScaleRandomPointFrom(GAME_IN_POINTS, -half, -side);
                var cmd = makeBoundShot(IN_DURATION, 1-serverId, returnerPoint, shotPoint, boundPoint);
                
                pointAnimationFrames.push(cmd);
                
                returnerPoint = {};
                returnerPoint.x = shotPoint.x;
                returnerPoint.y = shotPoint.y;
                
                shotPoint = {};
                shotPoint.x = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x);
                shotPoint.y = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y);
                
                side = -side;
                serverId = 1 - serverId;
                
                if (Math.random() < 0.5) {
                    half = -half;
                }
            }
            
            if (Math.random() < 0.5) {
                var netPoint = getAndScaleRandomPointFrom(NET_POINTS, -half, side);
                pointAnimationFrames.push(
                    makeNetShot(NET_DURATION, 1-serverId, returnerPoint, shotPoint, netPoint));
            } else {
                var outPoint = getAndScaleRandomPointFrom(GAME_OUT_POINTS, -half, -side);
                pointAnimationFrames.push(
                    makeOutShot(NET_DURATION, 1-serverId, returnerPoint, shotPoint, outPoint));
            }
        }
        
        function onWinButtonClick() {
            generateErrorFrames(1,1);
            //generateDoubleFaultFrames(0);
            //generateWinnerFrames(1,0);
            startPointAnimation();
        }
        
        initCourt();
    </script>
</body>
</html>