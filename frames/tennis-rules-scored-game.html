<html>
<head>
    <meta charset="utf-8">
    <style>
        .sCourt {
            background-color:#75c61e;
            position:relative;
        }
        .sField {
            background-color:#3271ac;
            position:absolute;
        }
        .sLine {
            background-color:white;
            position:absolute;
        }
        .sNet {
            background-color:#474535;
            position:absolute;
        }
        .sBall {
            background-color:yellow;
            -webkit-border-radius:50%;
            -moz-border-radius:50%;
            border-radius:50%;
            position:absolute;
        }
        .sBallShadow {
            background-color:black;
            -webkit-border-radius:50%/50%;
            -moz-border-radius:50%/50%;
            border-radius:50%/50%;
            position:absolute;
        }
        .sPlayer {
            -webkit-border-radius:50%;
            -moz-border-radius:50%;
            border-radius:50%;
            position:absolute;
            background-color:#edc436;
            border-color:black;
            border-width:1px;
            border-style:solid;
        }
        .sPlayerHint {
            position:absolute;
            width:120px;
            font-family:Verdana,Arial,Helvetica,sans-serif;
            font-size:10pt;
            font-weight:bold;
            color:black;
        }
        .sFlash {
            background-color:red;
            -webkit-border-radius:50%;
            -moz-border-radius:50%;
            border-radius:50%;
            position:absolute;
        }
        .sTvScoreBoard {
            display:block;
            float:none;
        }
        .sTvScoreBlock {
            float:none;
            clear:both;
        }
        .sTvSet, .sTvPoint, .sTvPlayerField {
            line-height:30px;
            text-align:center;
            vertical-align:middle;
            float:left;
            background:#2e2e2e;
            background:linear-gradient(to right, #7e7e7e, #2e2e2e, #7e7e7e);
            -webkit-border-radius:2px;
            -moz-border-radius:2px;
            border-radius:2px;
        }
        .sTvSet {
            width:30px;
            color:white;
            font-family:Courier,Arial,Verdana,Helvetica,sans-serif;
            font-size:14pt;
            font-weight:bold;
        }
        .sTvPlayerField {
            width:150px;
            color:white;
            font-family:Verdana,Arial,Helvetica,sans-serif;
            font-size:12pt;
            position:relative;
        }
        .sTvServiceMark {
            position:absolute;
            background-color:yellow;
            -webkit-border-radius:50%/50%;
            -moz-border-radius:50%/50%;
            border-radius:50%/50%;
            height:14px;
            width:14px;
            border-color:black;
            border-width:1px;
            border-style:solid;
            margin-top:-7px;
            top:50%;
            left:2px;
        }
        .sTvPoint {
            width: 40px;
            background: #fefcea;
            background: linear-gradient(to right, #fefcea, #f1da36, #fefcea);
            font-family:Courier,Arial,Verdana,Helvetica,sans-serif;
            font-size:14pt;
            font-weight:bold;
        }
        .sTvSituationsLayer {
            position:relative;
            height:27px;
            width:100px;
        }
        .sTvSituation {
            left:10px;
            top:1px;
            width:135px;
            color:yellow;
            background: #2e2e2e;
            background: linear-gradient(to top right, #7e7e7e, #2e2e2e, #7e7e7e);
            -webkit-border-radius:5px;
            -moz-border-radius:5px;
            border-radius:20px 7px 7px 7px;
            text-align:center;
            border-color:red;
            border-width:2px;
            border-style:solid;
            position:absolute;
            font-family:Verdana,Arial,Helvetica,sans-serif;
            font-size:12pt;
        }
        .sBigSb {
            background-color:#37584d;
        }
        .sBigSbTitle {
            font-family:Verdana,Arial,Helvetica,sans-serif;
            font-size:16pt;
            color:white;
            margin:7px 0 13px 0;
            text-align:center;
        }
        .sBigSbHint {
            font-family:Verdana,Arial,Helvetica,sans-serif;
            font-size:7pt;
            color:white;
            text-align:center;
        }
        .sBigSbDigit {
            width:16pt;
            font-family:Courier,Arial,Verdana,Helvetica,sans-serif;
            font-size:16pt;
            text-align:center;
            background-color:#2c2d28; 
            color:#daf447; 
            margin:2px; 
        }
        .sBigSbDigits {
            width:32pt;
            font-family:Courier,Arial,Verdana,Helvetica,sans-serif;
            font-size:16pt;
            text-align:center;
            background-color:#2c2d28; 
            color:#daf447; 
            margin:2px; 
        }
        .sBigSbPlayers {
            width:120px;
            font-family:Verdana,Arial,Helvetica,sans-serif;
            font-size:12pt;
            text-align:center;
            background-color:#edc436; 
            color:black;
            margin:2px; 
        }
        .sBigSbServiceMark {
            position:absolute;
            background-color:yellow;
            -webkit-border-radius:50%/50%;
            -moz-border-radius:50%/50%;
            border-radius:50%/50%;
            height:14px;
            width:14px;
            border-color:black;
            border-width:1px;
            border-style:solid;
            margin-top:-7px;
            margin-left:-7px;
            top:50%;
            left:50%;
        }
        .sBigSbServiceMarkContainer {
            height:17px;
            width:17px;
            position:relative;
        }
        .sPointHint {
            font-family:Verdana,Arial,Helvetica,sans-serif;
            font-size:12pt;
            color:black;
            width:500px;
        }
    </style>
</head>
<body>
    <table><tr>
    <td>
        <p>Примерно так выглядит табло на корте:</p>
        <table class="sBigSb">
            <tr>
                <td colspan="9"><div class="sBigSbTitle">COURT No. 18</div></td>
            </tr>
            <tr>
                <td colspan="4"><div class="sBigSbHint">PREVIOUS SETS</div></td>
                <td colspan="2"></td>
                <td><div class="sBigSbHint">SETS</div></td>
                <td><div class="sBigSbHint">GAMES</div></td>
                <td><div class="sBigSbHint">POINTS</div></td>
            </tr>
            <tr>
                <td><div id="mBigSbSet10" class="sBigSbDigit">1</div></td>
                <td><div id="mBigSbSet11" class="sBigSbDigit">1</div></td>
                <td><div id="mBigSbSet12" class="sBigSbDigit">1</div></td>
                <td><div id="mBigSbSet13" class="sBigSbDigit">1</div></td>
                <td><div id="mBigSbPlayer1" class="sBigSbPlayers">Иванов</div></td>
                <td><div class="sBigSbServiceMarkContainer">
                    <div id="mBigSbServiceMark1" class="sBigSbServiceMark"></div>
                </div></td>
                <td><div id="mBigSbSets1" class="sBigSbDigit">1</div></td>
                <td><div id="mBigSbGames1" class="sBigSbDigits">12</div></td>
                <td><div id="mBigSbPoints1" class="sBigSbDigits">27</div></td>
            </tr>
            <tr>
                <td><div id="mBigSbSet00" class="sBigSbDigit">2</div></td>
                <td><div id="mBigSbSet01" class="sBigSbDigit">2</div></td>
                <td><div id="mBigSbSet02" class="sBigSbDigit">2</div></td>
                <td><div id="mBigSbSet03" class="sBigSbDigit">2</div></td>
                <td><div id="mBigSbPlayer0" class="sBigSbPlayers">Петров</div></td>
                <td><div class="sBigSbServiceMarkContainer">
                    <div id="mBigSbServiceMark0" class="sBigSbServiceMark"></div>
                </div></td>
                <td><div id="mBigSbSets0" class="sBigSbDigit">1</div></td>
                <td><div id="mBigSbGames0" class="sBigSbDigits">12</div></td>
                <td><div id="mBigSbPoints0" class="sBigSbDigits">27</div></td>
            </tr>
        </table>
        
        <p>А так обычно отображают счет по TV:</p>
        <div id="mTvScoreBoard" class="sTvScoreBoard">
            <div class="sTvScoreBlock">
                <div class="sTvSituationsLayer">
                    <div id="mTvBreakpoint" class="sTvSituation">Breakpoint</div>
                    <div id="mTvSetpoint"   class="sTvSituation">Setpoint</div>
                    <div id="mTvMatchpiont" class="sTvSituation">Matchpoint</div>
                    <div id="mTvTiebreak"   class="sTvSituation">Tiebreak</div>
                </div>
            </div>
            <div class="sTvScoreBlock">
                <div class="sTvPlayerField">
                    <div id="mTvServiceMark1" class="sTvServiceMark"></div>
                    <div id="mTvPlayer1">Иванов</div>
                </div>
                <div id="mTvPoint1" class="sTvPoint">40</div>
                <div id="mTvSet10" class="sTvSet">0</div>
                <div id="mTvSet11" class="sTvSet">0</div>
                <div id="mTvSet12" class="sTvSet">0</div>
                <div id="mTvSet13" class="sTvSet">0</div>
                <div id="mTvSet14" class="sTvSet">0</div>
                <div style="clear:both"></div>
            </div>
            <div class="sTvScoreBlock">
                <div class="sTvPlayerField">
                    <div id="mTvServiceMark0" class="sTvServiceMark"></div>
                    <div id="mTvPlayer0">Петров</div>
                </div>
                <div id="mTvPoint0" class="sTvPoint">15</div>
                <div id="mTvSet00" class="sTvSet">0</div>
                <div id="mTvSet01" class="sTvSet">0</div>
                <div id="mTvSet02" class="sTvSet">0</div>
                <div id="mTvSet03" class="sTvSet">0</div>
                <div id="mTvSet04" class="sTvSet">0</div>
                <div style="clear:both"></div>
            </div>
            <div style="clear:both"></div>
        </div>
        
        <p>Попробуйте поиграть "виртуально":</p>
        
        <table class="sBigSb">
            <tr>
                <td></td>
                <td><div class="sBigSbHint">SETS</div></td>
                <td><div class="sBigSbHint">GAMES</div></td>
                <td><div class="sBigSbHint">POINTS</div></td>
            </tr>
            <tr>
                <td><div id="mBigSbPlayer1" class="sBigSbPlayers">Иванов выиграет:</div></td>
                <td><input id="mLooseSet1Btn" type="button" value="Сет"  onclick="onLooseSetButtonClick()"></td>
                <td><input id="mLooseGame1Btn" type="button" value="Гейм" onclick="onLooseGameButtonClick()"></td>
                <td><input id="mLoosePoint1Btn" type="button" value="Очко" onclick="onLooseButtonClick()"></td>
            </tr>
            <tr>
                <td><div id="mBigSbPlayer0" class="sBigSbPlayers">Петров выиграет:</div></td>
                <td><input id="mLooseSet0Btn" type="button" value="Сет"  onclick="onWinSetButtonClick()"></td>
                <td><input id="mLooseGame0Btn" type="button" value="Гейм" onclick="onWinGameButtonClick()"></td>
                <td><input id="mLoosePoint0Btn" type="button" value="Очко" onclick="onWinButtonClick()"></td>
            </tr>
        </table>
        
        <p>Не все ясно? Попробуйте <input id="mPlayAgainBtn" type="button" value="ещё раз." onclick="onPlayAgain()"></p>
    </td>
    
    <td>
        <div id="mCourt" class="sCourt">
            <div id="mField" class="sField"></div>

            <div id="mLineLeftOuter" class="sLine"></div>
            <div id="mLineRightOuter" class="sLine"></div>
            <div id="mLineLeftInner" class="sLine"></div>
            <div id="mLineRightInner" class="sLine"></div>
            <div id="mLineTopOuter" class="sLine"></div>
            <div id="mLineBottomOuter" class="sLine"></div>
            <div id="mLineTopInner" class="sLine"></div>
            <div id="mLineBottomInner" class="sLine"></div>
            <div id="mLineCentral" class="sLine"></div>
            <div id="mLineTopMark" class="sLine"></div>
            <div id="mLineBottomMark" class="sLine"></div>
            
            <div id="mNet" class="sNet"></div>

            <div id="mMyPlayer" class="sPlayer"><div id="mMyPlayerHint" class="sPlayerHint">Петров</div></div>
            <div id="mHisPlayer" class="sPlayer"><div id="mHisPlayerHint" class="sPlayerHint">Иванов</div></div>
            
            <div id="mBallShadow" class="sBallShadow"></div>
            <div id="mBall" class="sBall"></div>
            <div id="mFlash" class="sFlash"></div>
        </div>
    </td>
    </tr>
    <tr>
        <td colspan="2"><div id="mPointHint" class="sPointHint">Point hint</div></td>
    </tr>
    </table>
    
    
    <script>
        var PAIR_FIELD_WIDTH     = 10.973; //metres
        var SINGLE_FIELD_WIDTH   = 8.23; 
        var FIELD_LENGTH         = 11.89;
        var SERVICE_FIELD_LENGTH = 6.40;
        var COURT_LENGTH         = (2 * FIELD_LENGTH) + 6;
        var COURT_WIDTH          = PAIR_FIELD_WIDTH + 6;
        var NET_WIDTH            = PAIR_FIELD_WIDTH + 2 * 0.914;
        var LINE_WIDTH           = 0.25;
        var MARK_LENGTH          = LINE_WIDTH * 2;
        
        var BALL_RADIUS          = 1.5 * LINE_WIDTH;
        var FLASH_RADIUS         = BALL_RADIUS * 0.8;
        var PLAYER_HEIGHT        = BALL_RADIUS * 2;
        var PLAYER_WIDTH         = PLAYER_HEIGHT * 2;

        var VIEW_WIDTH = 300; //pixels
        
        //типы действий на площадке
        var SERVICE_ID    = 1;  //подача
        var BOUND_SHOT_ID = 2;  //удачно отбиваем мяч с отскока
        var BOUND_LOSS_ID = 4;  //не отбиваем мяч с отскока
        var NET_ID        = 8;  //в сетку
        var OUT_ID        = 16; //в аут
        var PAUSE_ID      = 32; //пауза

        //miliseconds
        var SERVICE_DURATION = 1500;
        var NET_DURATION     = 1000;
        var OUT_DURATION     = 1700;
        var IN_DURATION      = 1200;
        var PAUSE_DURATION   = 1000;
        
        var THIRD_POINT_SCALE = 0.25;
        
        var GAME_OUT_POINTS;
        var GAME_IN_POINTS;
        var SERVICE_FROM_POINTS;
        var SERVICE_IN_POINTS;
        var SERVICE_OUT_POINTS;
        var NET_POINTS;
        
        //globals
        var animationStartTime;
        var pointAnimationFrames;
        
        var gPointFor = 0;
        var gScore = new CScore(0);
        var gPointHint;
        
        function playerNameFor(player) {
            return ["Петров", "Иванов"][player % 2];
        }
        
        function playerDivFor(player) {
            return ((player % 2) == 0) ? mMyPlayer : mHisPlayer;
        }
        
        function lenToView(len) {
            return (len * VIEW_WIDTH) / COURT_WIDTH;
        }
        
        function xToViewLeft(x) {
            return ((x + COURT_WIDTH / 2) * VIEW_WIDTH) / COURT_WIDTH;
        }
        
        function yToViewTop(y) {
            return ((y + COURT_LENGTH / 2) * VIEW_WIDTH) / COURT_WIDTH;
        }
        
        function drawVerticalLine(lineDiv, x, y1, y2) { //assert: y2>y1
            var lineWidth = (LINE_WIDTH * VIEW_WIDTH) / COURT_WIDTH;
        
            lineDiv.style.width  = lineWidth;
            lineDiv.style.height = (yToViewTop(y2) - yToViewTop(y1)) + lineWidth;
            
            lineDiv.style.top = yToViewTop(y1) - lineWidth/2;
            lineDiv.style.left = xToViewLeft(x) - lineWidth/2;
        }
        
        function drawHorizontalLine(lineDiv, y, x1, x2) { //assert: x2>x1
            var lineWidth = (LINE_WIDTH * VIEW_WIDTH) / COURT_WIDTH;
        
            lineDiv.style.width  = (xToViewLeft(x2) - xToViewLeft(x1)) + lineWidth;
            lineDiv.style.height = lineWidth;
            
            lineDiv.style.top = yToViewTop(y) - lineWidth/2;
            lineDiv.style.left = xToViewLeft(x1) - lineWidth/2;
        }
        
        function initBall() {
            mBall.style.height = 2 * lenToView(BALL_RADIUS);
            mBall.style.width = 2 * lenToView(BALL_RADIUS);
            
            mBallShadow.style.height = 2 * lenToView(BALL_RADIUS);
            mBallShadow.style.width = 2 * lenToView(BALL_RADIUS);
            
            moveBallTo(0,0);
            moveBallShadowTo(0,0);
            
            setFlashVisible(false);
        }
        
        function initFlash() {
            mFlash.style.height = 2 * lenToView(FLASH_RADIUS);
            mFlash.style.width = 2 * lenToView(FLASH_RADIUS);
        }
        
        function initPlayer(playerDiv) {
            playerDiv.style.height = lenToView(PLAYER_HEIGHT);
            playerDiv.style.width = lenToView(PLAYER_WIDTH);
        }

        function movePlayersToNet() {
            movePlayerTo(mMyPlayer,  0,  PLAYER_HEIGHT);
            movePlayerTo(mHisPlayer, 0, -PLAYER_HEIGHT);

            moveBallTo(0,0);
            moveBallShadowTo(0,0);
            
            setFlashVisible(false);
        }
        
        function movePlayersToBench() {
            movePlayerTo(mMyPlayer,  -(COURT_WIDTH + PAIR_FIELD_WIDTH)/4,  PLAYER_HEIGHT);
            movePlayerTo(mHisPlayer, -(COURT_WIDTH + PAIR_FIELD_WIDTH)/4, -PLAYER_HEIGHT);

            moveBallTo(0,0);
            moveBallShadowTo(0,0);
            
            setFlashVisible(false);
        }
        
        function initPlayers() {
            initPlayer(mMyPlayer);
            mMyPlayerHint.style.left = lenToView(PLAYER_WIDTH) + 5;

            initPlayer(mHisPlayer);
            mHisPlayerHint.style.left = lenToView(PLAYER_WIDTH) + 5;
        }
        
        function initGameOutPoints() {
            GAME_OUT_POINTS = [];

            GAME_OUT_POINTS[0] = {};
            GAME_OUT_POINTS[0].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            GAME_OUT_POINTS[0].y = SERVICE_FIELD_LENGTH/2;

            GAME_OUT_POINTS[1] = {};
            GAME_OUT_POINTS[1].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            GAME_OUT_POINTS[1].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_OUT_POINTS[2] = {};
            GAME_OUT_POINTS[2].x = (PAIR_FIELD_WIDTH + COURT_WIDTH)/4;
            GAME_OUT_POINTS[2].y = SERVICE_FIELD_LENGTH/2;

            GAME_OUT_POINTS[3] = {};
            GAME_OUT_POINTS[3].x = (PAIR_FIELD_WIDTH + COURT_WIDTH)/4;
            GAME_OUT_POINTS[3].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_OUT_POINTS[4] = {};
            GAME_OUT_POINTS[4].x = SINGLE_FIELD_WIDTH/12;
            GAME_OUT_POINTS[4].y = (2*FIELD_LENGTH + COURT_LENGTH)/4;

            GAME_OUT_POINTS[5] = {};
            GAME_OUT_POINTS[5].x = SINGLE_FIELD_WIDTH/4;
            GAME_OUT_POINTS[5].y = (2*FIELD_LENGTH + COURT_LENGTH)/4;

            GAME_OUT_POINTS[6] = {};
            GAME_OUT_POINTS[6].x = SINGLE_FIELD_WIDTH*5/12;
            GAME_OUT_POINTS[6].y = (2*FIELD_LENGTH + COURT_LENGTH)/4;
        }
        
        function initGameInPoints() {
            GAME_IN_POINTS = [];
            
            GAME_IN_POINTS[0] = {};
            GAME_IN_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            GAME_IN_POINTS[0].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_IN_POINTS[1] = {};
            GAME_IN_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            GAME_IN_POINTS[1].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            GAME_IN_POINTS[2] = {};
            GAME_IN_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            GAME_IN_POINTS[2].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;
            
            GAME_IN_POINTS[3] = {};
            GAME_IN_POINTS[3].x = SINGLE_FIELD_WIDTH/12;
            GAME_IN_POINTS[3].y = SERVICE_FIELD_LENGTH/2;

            GAME_IN_POINTS[4] = {};
            GAME_IN_POINTS[4].x = SINGLE_FIELD_WIDTH/4;
            GAME_IN_POINTS[4].y = SERVICE_FIELD_LENGTH/2;

            GAME_IN_POINTS[5] = {};
            GAME_IN_POINTS[5].x = SINGLE_FIELD_WIDTH*5/12;
            GAME_IN_POINTS[5].y = SERVICE_FIELD_LENGTH/2;
        }
        
        function initServiceFromPoints() {
            SERVICE_FROM_POINTS = [];
            
            SERVICE_FROM_POINTS[0] = {};
            SERVICE_FROM_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            SERVICE_FROM_POINTS[0].y = FIELD_LENGTH + PLAYER_HEIGHT;
            
            SERVICE_FROM_POINTS[1] = {};
            SERVICE_FROM_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            SERVICE_FROM_POINTS[1].y = FIELD_LENGTH + PLAYER_HEIGHT;

            SERVICE_FROM_POINTS[2] = {};
            SERVICE_FROM_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            SERVICE_FROM_POINTS[2].y = FIELD_LENGTH + PLAYER_HEIGHT;
        }
        
        function initServiceOutPoints() {
            SERVICE_OUT_POINTS = [];
            
            SERVICE_OUT_POINTS[0] = {};
            SERVICE_OUT_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            SERVICE_OUT_POINTS[0].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            SERVICE_OUT_POINTS[1] = {};
            SERVICE_OUT_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            SERVICE_OUT_POINTS[1].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            SERVICE_OUT_POINTS[2] = {};
            SERVICE_OUT_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            SERVICE_OUT_POINTS[2].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;

            SERVICE_OUT_POINTS[3] = {};
            SERVICE_OUT_POINTS[3].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            SERVICE_OUT_POINTS[3].y = SERVICE_FIELD_LENGTH/2;

            SERVICE_OUT_POINTS[4] = {};
            SERVICE_OUT_POINTS[4].x = (SINGLE_FIELD_WIDTH + PAIR_FIELD_WIDTH)/4;
            SERVICE_OUT_POINTS[4].y = (SERVICE_FIELD_LENGTH + FIELD_LENGTH)/2;
        }
        
        function initNetPoints() {
            NET_POINTS = [];
            
            NET_POINTS[0] = {};
            NET_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            NET_POINTS[0].y = BALL_RADIUS;

            NET_POINTS[1] = {};
            NET_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            NET_POINTS[1].y = BALL_RADIUS;

            NET_POINTS[2] = {};
            NET_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            NET_POINTS[2].y = BALL_RADIUS;
        }

        function initServiceInPoints() {
            SERVICE_IN_POINTS = [];
            
            SERVICE_IN_POINTS[0] = {};
            SERVICE_IN_POINTS[0].x = SINGLE_FIELD_WIDTH/12;
            SERVICE_IN_POINTS[0].y = SERVICE_FIELD_LENGTH - 2*BALL_RADIUS;

            SERVICE_IN_POINTS[1] = {};
            SERVICE_IN_POINTS[1].x = SINGLE_FIELD_WIDTH/4;
            SERVICE_IN_POINTS[1].y = SERVICE_FIELD_LENGTH - 2*BALL_RADIUS;

            SERVICE_IN_POINTS[2] = {};
            SERVICE_IN_POINTS[2].x = SINGLE_FIELD_WIDTH*5/12;
            SERVICE_IN_POINTS[2].y = SERVICE_FIELD_LENGTH - 2*BALL_RADIUS;
        }
        
        function initPoints() {
            initGameOutPoints();
            initGameInPoints();
            initServiceFromPoints();
            initServiceInPoints();
            initServiceOutPoints();
            initNetPoints();
        }
        
        function initCourt() {
            initPoints();
            
            mCourt.style.width  = VIEW_WIDTH;
            mCourt.style.height = lenToView(COURT_LENGTH);
            
            mField.style.width = lenToView(PAIR_FIELD_WIDTH);
            mField.style.height = lenToView(2 * FIELD_LENGTH);
            
            mField.style.top = yToViewTop(-FIELD_LENGTH);
            mField.style.left = xToViewLeft(-PAIR_FIELD_WIDTH/2);
            
            drawVerticalLine(mLineLeftOuter, -PAIR_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);
            drawVerticalLine(mLineRightOuter, PAIR_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);

            drawVerticalLine(mLineLeftInner, -SINGLE_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);
            drawVerticalLine(mLineRightInner, SINGLE_FIELD_WIDTH/2, -FIELD_LENGTH, FIELD_LENGTH);

            drawVerticalLine(mLineCentral, 0, -SERVICE_FIELD_LENGTH, SERVICE_FIELD_LENGTH);

            drawVerticalLine(mLineTopMark, 0, -FIELD_LENGTH, -FIELD_LENGTH + MARK_LENGTH);
            drawVerticalLine(mLineBottomMark, 0, FIELD_LENGTH - MARK_LENGTH, FIELD_LENGTH);
            
            drawHorizontalLine(mLineTopOuter, -FIELD_LENGTH, -PAIR_FIELD_WIDTH/2, PAIR_FIELD_WIDTH/2);
            drawHorizontalLine(mLineBottomOuter,  FIELD_LENGTH, -PAIR_FIELD_WIDTH/2, PAIR_FIELD_WIDTH/2);

            drawHorizontalLine(mLineTopInner, -SERVICE_FIELD_LENGTH, -SINGLE_FIELD_WIDTH/2, SINGLE_FIELD_WIDTH/2);
            drawHorizontalLine(mLineBottomInner, SERVICE_FIELD_LENGTH, -SINGLE_FIELD_WIDTH/2, SINGLE_FIELD_WIDTH/2);

            drawHorizontalLine(mNet, 0, -NET_WIDTH/2, NET_WIDTH/2);
            
            initBall();
            initFlash();
            initPlayers();
            
            movePlayersToNet();
            hidePointHiht();
        } 
        
        function movePlayerTo(playerDiv, x, y) {
            playerDiv.style.left = xToViewLeft(x) - lenToView(PLAYER_WIDTH/2);
            playerDiv.style.top  = yToViewTop(y) - lenToView(PLAYER_HEIGHT/2);
        }
        
        function moveBallTo(x, y) {
            mBall.style.left = xToViewLeft(x) - lenToView(BALL_RADIUS);
            mBall.style.top  = yToViewTop(y) - lenToView(BALL_RADIUS);
        }
        
        function moveBallShadowTo(x, y) {
            mBallShadow.style.left = xToViewLeft(x) - lenToView(BALL_RADIUS);
            mBallShadow.style.top  = yToViewTop(y) - lenToView(BALL_RADIUS);
        }

        function setFlashVisible(isVisible) {
            if (isVisible) {
                mFlash.style.display = 'block';
            } else {
                mFlash.style.display = 'none';
            }
        }
        
        function moveFlashTo(x, y) {
            mFlash.style.left = xToViewLeft(x) - lenToView(FLASH_RADIUS);
            mFlash.style.top  = yToViewTop(y) - lenToView(FLASH_RADIUS);
            setFlashVisible(true);
        }
        
        function CCourtAction(actionType, duration, returnerId, returnerPoint, 
                              startBallPoint, boundBallPoint, afterBoundPart) {
            this.actionType = actionType;
            this.duration = duration;
            this.returnerId = returnerId;
            this.returnerPoint = returnerPoint;
            this.shotPoint = startBallPoint;
            this.boundPoint = boundBallPoint;
            this.afterBoundPart = afterBoundPart;
        }
        
        function makeService(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            return new CCourtAction(SERVICE_ID, duration, returnerId, returnerPoint,
                                    shotPoint, boundPoint, 
                                    1);
        }
        
        function makeBoundShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            var x1,y1,x2,y2;
            
            x1 = shotPoint.x;
            y1 = shotPoint.y;
            
            x2 = boundPoint.x;
            y2 = boundPoint.y;
            
            var t,x3,y3;
            
            t = 2 - 0.3;
            y3 = bezier2(t, y1, y2);
            x3 = bezier2(t, x1, x2);
            
            if ((y3 < -(COURT_LENGTH/2)) || ((COURT_LENGTH/2) < y3)) {
                t = 1 + 0.3;
                y3 = bezier2(t, y1, y2);
                if (y3 < -(COURT_LENGTH/2)) {
                    y3 = -(COURT_LENGTH/2);
                } else if (y3 > (COURT_LENGTH/2)) {
                    y3 = (COURT_LENGTH/2);
                }
                t = (y3-y1)/(y2-y1);
                x3 = bezier2(t,x1,x2);
            }
            
            if (x3 < -(COURT_WIDTH/2)) {
                x3 = -(COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            } else if (x3 > (COURT_WIDTH/2)) {
                x3 = (COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            }

            return new CCourtAction(BOUND_SHOT_ID, duration, returnerId, returnerPoint,
                                    shotPoint, boundPoint, 
                                    t-1);
        }

        function makeBoundLossShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            var x1,y1,x2,y2;
            
            x1 = shotPoint.x;
            y1 = shotPoint.y;
            
            x2 = boundPoint.x;
            y2 = boundPoint.y;
            
            var t, x3,y3;

            if (y1 < y2) {
                y3 = (COURT_LENGTH/2);
            } else {
                y3 = -(COURT_LENGTH/2);
            }
            
            t = (y3-y1)/(y2-y1);
            x3 = bezier2(t, x1, x2);
            
            if (x3 < -(COURT_WIDTH/2)) {
                x3 = -(COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            } else if (x3 > (COURT_WIDTH/2)) {
                x3 = (COURT_WIDTH/2);
                t = (x3-x1)/(x2-x1);
            }

            return new CCourtAction(BOUND_LOSS_ID, duration, returnerId, returnerPoint, 
                                    shotPoint, boundPoint, 
                                    t-1);
        }
        
        function makeNetShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            return new CCourtAction(NET_ID, duration, returnerId, returnerPoint, 
                                    shotPoint, boundPoint, 
                                    0.5);
        }
        
        function makeOutShot(duration, returnerId, returnerPoint, shotPoint, boundPoint) {
            var outShot = makeBoundLossShot(duration, returnerId, returnerPoint, shotPoint, boundPoint);
            outShot.actionType = OUT_ID;
            return outShot;
        }
        
        function makePause(duration) {
            return new CCourtAction(PAUSE_ID, duration, null/*returnerId*/, null/*returnerPoint*/, 
                                    null/*shotPoint*/, null/*boundPoint*/, 
                                    0.5);
        }
        
        function bezier2(t, a, b) {
            return (1-t)*a + t*b;
        }
        
        function bezier3(t, a, b, c) {
            return t*t*a + 2*(1-t)*t*b + (1-t)*(1-t)*c;
        }
        
        function getBezierThirdPoint(p1, p2) {
            var k = THIRD_POINT_SCALE;
            if (p1.x >= p2.x)
                k = -k;
            
            var p = {};
            p.x =  k*(p2.y - p1.y) + (p2.x - p1.x)/2 + p1.x;
            p.y = -k*(p2.x - p1.x) + (p2.y - p1.y)/2 + p1.y;
            return p;
        }
        
        function getCurrentFrame() {return pointAnimationFrames[0];}
        
        function animateService(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;
            
            movePlayerTo(playerDivFor(cmd.returnerId),   cmd.returnerPoint.x, cmd.returnerPoint.y);
            movePlayerTo(playerDivFor(1-cmd.returnerId), cmd.shotPoint.x, cmd.shotPoint.y);
            
            moveBallTo(cmd.shotPoint.x, cmd.shotPoint.y);
            moveBallShadowTo(cmd.shotPoint.x, cmd.shotPoint.y);
            
            if (Math.floor(timePassed*6/cmd.duration) % 2 == 0) {
                if (cmd.shotPoint.y > 0) {
                    moveFlashTo(cmd.shotPoint.x + BALL_RADIUS, cmd.shotPoint.y - BALL_RADIUS);
                } else {
                    moveFlashTo(cmd.shotPoint.x - BALL_RADIUS, cmd.shotPoint.y + BALL_RADIUS);
                }
            } else {
                setFlashVisible(false);
            }

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateService);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function animateBoundShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            var boundDuration = cmd.duration / (1 + cmd.afterBoundPart);
            
            if (timePassed <= boundDuration) {  //draw ball before bound part (parabolic curve)
                var thirdPoint = getBezierThirdPoint(cmd.shotPoint, cmd.boundPoint);
                
                var t = (boundDuration - timePassed) / boundDuration;
                setFlashVisible(false);
                moveBallTo(
                    bezier3(t, cmd.shotPoint.x, thirdPoint.x, cmd.boundPoint.x),
                    bezier3(t, cmd.shotPoint.y, thirdPoint.y, cmd.boundPoint.y));
            } else {                            //draw ball after bound 
                var t = 1 + (timePassed - boundDuration) / boundDuration;
                moveFlashTo(cmd.boundPoint.x, cmd.boundPoint.y);
                moveBallTo(
                    bezier2(t, cmd.shotPoint.x, cmd.boundPoint.x),
                    bezier2(t, cmd.shotPoint.y, cmd.boundPoint.y));
            }
                
            var t = timePassed/cmd.duration;
            
            moveBallShadowTo(
                bezier2(t, cmd.shotPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t, cmd.shotPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));
                    
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t, cmd.returnerPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t*t, cmd.returnerPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateBoundShot);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function animateBoundLossShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            var t = timePassed*(1 + cmd.afterBoundPart)/cmd.duration;
            var tFloor = Math.floor(t);
            
            var boundPoint1 = {};
            var boundPoint2 = {};
            
            boundPoint1.x = bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint1.y = bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y);

            boundPoint2.x = bezier2(tFloor + 1, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint2.y = bezier2(tFloor + 1, cmd.shotPoint.y, cmd.boundPoint.y);
            
            var thirdPoint = getBezierThirdPoint(boundPoint1, boundPoint2);
            moveBallTo(
                bezier3(t-tFloor, boundPoint2.x, thirdPoint.x, boundPoint1.x),
                bezier3(t-tFloor, boundPoint2.y, thirdPoint.y, boundPoint1.y));
            
            setFlashVisible(false);
            if (tFloor > 0) {
                moveFlashTo(
                    bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x),
                    bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y));
            }
            
            t = timePassed/cmd.duration;
            moveBallShadowTo(
                bezier2(t, cmd.shotPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t, cmd.shotPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));
                    
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t/2, cmd.returnerPoint.x, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t*t/2, cmd.returnerPoint.y, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.y, cmd.boundPoint.y)));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateBoundLossShot);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function animateNetShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;
            
            var boundDuration = cmd.duration / (1 + cmd.afterBoundPart);
            
            if (timePassed <= boundDuration) {  //draw ball before bound part (parabolic curve)
                var t = timePassed / boundDuration;
                setFlashVisible(false);
                var x = bezier2(t, cmd.shotPoint.x, cmd.boundPoint.x);
                var y = bezier2(t, cmd.shotPoint.y, cmd.boundPoint.y);
                moveBallTo(x, y);
                moveBallShadowTo(x,y);
            } else {                            //draw ball after bound 
                moveFlashTo(cmd.boundPoint.x, cmd.boundPoint.y);

                var t = (timePassed - boundDuration)/(boundDuration * cmd.afterBoundPart);
                var x;
                if (cmd.shotPoint.x > cmd.boundPoint.x) {
                    x = bezier2(t, cmd.boundPoint.x, cmd.boundPoint.x-BALL_RADIUS*2);
                } else {
                    x = bezier2(t, cmd.boundPoint.x, cmd.boundPoint.x+BALL_RADIUS*2);
                }
                
                moveBallTo(x, cmd.boundPoint.y);
                moveBallShadowTo(x, cmd.boundPoint.y);
            }
            
            var t = timePassed/(2 * cmd.duration);
            
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t, cmd.returnerPoint.x, cmd.boundPoint.x),
                bezier2(t*t, cmd.returnerPoint.y, cmd.boundPoint.y));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateNetShot);
            } else {
                nextPointAnimationFrame();
            }
        }

        function animateOutShot(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            var t = timePassed*(1 + cmd.afterBoundPart)/cmd.duration;
            var tFloor = Math.floor(t);
            
            var boundPoint1 = {};
            var boundPoint2 = {};
            
            boundPoint1.x = bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint1.y = bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y);

            boundPoint2.x = bezier2(tFloor + 1, cmd.shotPoint.x, cmd.boundPoint.x);
            boundPoint2.y = bezier2(tFloor + 1, cmd.shotPoint.y, cmd.boundPoint.y);
            
            var thirdPoint = getBezierThirdPoint(boundPoint1, boundPoint2);
            moveBallTo(
                bezier3(t-tFloor, boundPoint2.x, thirdPoint.x, boundPoint1.x),
                bezier3(t-tFloor, boundPoint2.y, thirdPoint.y, boundPoint1.y));
            
            setFlashVisible(false);
            if (tFloor > 0) {
                moveFlashTo(
                    bezier2(tFloor, cmd.shotPoint.x, cmd.boundPoint.x),
                    bezier2(tFloor, cmd.shotPoint.y, cmd.boundPoint.y));
            }
            
            t = timePassed/cmd.duration;
            moveBallShadowTo(
                bezier2(t, cmd.shotPoint.x, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t, cmd.shotPoint.y, 
                    bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y)));
                    
            movePlayerTo(playerDivFor(cmd.returnerId),
                bezier2(t*t/2, cmd.returnerPoint.x, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.x, cmd.boundPoint.x)),
                bezier2(t*t/2, cmd.returnerPoint.y, 
                    bezier2(1 + cmd.afterBoundPart/2, cmd.shotPoint.y, cmd.boundPoint.y)));

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animateOutShot);
            } else {
                nextPointAnimationFrame();
            }
        }

        function animatePause(time) {
            var timePassed = time - animationStartTime;
            var cmd = getCurrentFrame();
            if (cmd == null) {
                nextPointAnimationFrame();
                return;
            }

            if (timePassed < 0) timePassed = 0;
            if (timePassed > cmd.duration) timePassed = cmd.duration;

            if (timePassed < cmd.duration) {
                requestAnimationFrame(animatePause);
            } else {
                nextPointAnimationFrame();
            }
        }
        
        function nextPointAnimationFrame() {
            pointAnimationFrames.shift();
            startPointAnimation();
        }
        
        function startPointAnimation() {
            if (pointAnimationFrames[0] == null) {
                gScore.winPointBy(gPointFor);
                
                viewScore();
                viewPointHiht();
                
                allButtonsDisabledTo(false);

                return;
            }
            
            animationStartTime = performance.now();
            switch(pointAnimationFrames[0].actionType) {
            case SERVICE_ID:    requestAnimationFrame(animateService); break;
            case BOUND_SHOT_ID: requestAnimationFrame(animateBoundShot); break;
            case BOUND_LOSS_ID: requestAnimationFrame(animateBoundLossShot); break;
            case NET_ID:        requestAnimationFrame(animateNetShot); break;
            case OUT_ID:        requestAnimationFrame(animateOutShot); break;
            case PAUSE_ID:      requestAnimationFrame(animatePause); break;
            }
        }
        
        function getRandomPointFrom(arr) {
            var point = arr[Math.floor(Math.random() * (arr.length))];

            var pointCopy = {};
            pointCopy.x = point.x;
            pointCopy.y = point.y;

            return pointCopy;
        }
        
        function getAndScaleRandomPointFrom(arr, xscale, yscale) {
            var point = getRandomPointFrom(arr);
            point.x = xscale * point.x;
            point.y = yscale * point.y;
            
            return point;
        }
        
        function getCurrentHalf() {
            return gScore.serviceHalf(); 
        }
        
        function generateDoubleFaultFrames(serverId) {
            var half = getCurrentHalf();
            var side = 1;
            
            gPointHint = playerNameFor(1-serverId) + " выиграл очко, потому что " + playerNameFor(serverId) + 
                         " дважды ошибся на подаче."
            
            if ((serverId % 2) != 0) {
                side = -1;
                half = -half;
            }
            
            pointAnimationFrames = [];
            
            for (var i=0; i<2; i++) {
                var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
                var returnerPoint = {};
                returnerPoint.x = -shotPoint.x;
                returnerPoint.y = -shotPoint.y;
                
                generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side);
                
                if (i < 1) {
                    pointAnimationFrames.push(makePause(PAUSE_DURATION));
                }
            }
        }

        function generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side) {
            pointAnimationFrames.push(
                makeService(SERVICE_DURATION, 1-serverId, returnerPoint, shotPoint, shotPoint));
                
            if (Math.random() < 0.5) { //in out
                var outPoint = getAndScaleRandomPointFrom(SERVICE_OUT_POINTS, -half, -side);
                
                pointAnimationFrames.push(
                    makeOutShot(OUT_DURATION, 1-serverId, returnerPoint, shotPoint, outPoint));
            } else { //in net
                var netPoint = getAndScaleRandomPointFrom(NET_POINTS, -half, side);
                
                pointAnimationFrames.push(
                    makeNetShot(NET_DURATION, 1-serverId, returnerPoint, shotPoint, netPoint));
            }
        }
        
        function generateWinnerFrames(serverId, winnerId) {
            var half = getCurrentHalf();
            var side = 1;
            
            gPointHint = playerNameFor(winnerId) + " активно выиграл очко, потому что " + 
                         playerNameFor(1-winnerId) + " не смог отбить его удар.";
            
            if ((serverId % 2) != 0) {
                side = -1;
                half = -half;
            }
            
            pointAnimationFrames = [];
            
            var gameShotCount = Math.floor(Math.random() * 4)*2; //odd!
            if (serverId != winnerId) {
                gameShotCount = gameShotCount + 1;
            }
            
            var isBadFirstService = false;
            if (Math.random() < 0.3) {
                isBadFirstService = true;
                
                var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
                var returnerPoint = {};
                returnerPoint.x = -shotPoint.x;
                returnerPoint.y = -shotPoint.y;
                
                generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side);
                pointAnimationFrames.push(makePause(PAUSE_DURATION));
            }
            
            var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
            var returnerPoint = {};
            returnerPoint.x = -shotPoint.x;
            returnerPoint.y = -shotPoint.y;
            
            pointAnimationFrames.push(
                makeService(SERVICE_DURATION, 1-serverId, returnerPoint, shotPoint, shotPoint));
            
            for (var i=0; i<gameShotCount; i++) {
                var boundPoint = (i == 0) ? getAndScaleRandomPointFrom(SERVICE_IN_POINTS, -half, -side)
                                          : getAndScaleRandomPointFrom(GAME_IN_POINTS, -half, -side);
                var cmd = makeBoundShot(IN_DURATION, 1-serverId, returnerPoint, shotPoint, boundPoint);
                
                pointAnimationFrames.push(cmd);
                
                returnerPoint = {};
                returnerPoint.x = shotPoint.x;
                returnerPoint.y = shotPoint.y;
                
                shotPoint = {};
                shotPoint.x = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x);
                shotPoint.y = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y);
                
                side = -side;
                serverId = 1 - serverId;
                
                if (Math.random() < 0.5) {
                    half = -half;
                }
            }
            
            var boundPoint = (gameShotCount == 0) ? 
                  getAndScaleRandomPointFrom(SERVICE_IN_POINTS, -half, -side)
                : getAndScaleRandomPointFrom(GAME_IN_POINTS, -half, -side);
                
            pointAnimationFrames.push(
                makeBoundLossShot(IN_DURATION, 1-serverId, returnerPoint, shotPoint, boundPoint));
                
            if (isBadFirstService) {
                gPointHint += (" При этом " + playerNameFor(serverId) + " один раз ошибся на подаче.");
            }
        }
        
        function generateErrorFrames(serverId, winnerId) {
            var half = getCurrentHalf();
            var side = 1;
            
            gPointHint = playerNameFor(winnerId) + " выиграл очко, потому что " + playerNameFor(1-winnerId);

            if ((serverId % 2) != 0) {
                side = -1;
                half = -half;
            }
            
            pointAnimationFrames = [];
            
            var gameShotCount = Math.floor(Math.random() * 4)*2 + 1; 
            if (serverId != winnerId) {
                gameShotCount = gameShotCount + 1;
            }
            
            var isBadFirstService = false;
            if (Math.random() < 0.3) {
                isBadFirstService = true;
                
                var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
                var returnerPoint = {};
                returnerPoint.x = -shotPoint.x;
                returnerPoint.y = -shotPoint.y;
                
                generateBadServiceTry(serverId, returnerPoint, shotPoint, half, side);
                pointAnimationFrames.push(makePause(PAUSE_DURATION));
            }
            
            var shotPoint = getAndScaleRandomPointFrom(SERVICE_FROM_POINTS, half, side);
            var returnerPoint = {};
            returnerPoint.x = -shotPoint.x;
            returnerPoint.y = -shotPoint.y;
            
            pointAnimationFrames.push(
                makeService(SERVICE_DURATION, 1-serverId, returnerPoint, shotPoint, shotPoint));
            
            for (var i=0; i<gameShotCount; i++) {
                var boundPoint = (i == 0) ? getAndScaleRandomPointFrom(SERVICE_IN_POINTS, -half, -side)
                                          : getAndScaleRandomPointFrom(GAME_IN_POINTS, -half, -side);
                var cmd = makeBoundShot(IN_DURATION, 1-serverId, returnerPoint, shotPoint, boundPoint);
                
                pointAnimationFrames.push(cmd);
                
                returnerPoint = {};
                returnerPoint.x = shotPoint.x;
                returnerPoint.y = shotPoint.y;
                
                shotPoint = {};
                shotPoint.x = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.x, cmd.boundPoint.x);
                shotPoint.y = bezier2(1 + cmd.afterBoundPart, cmd.shotPoint.y, cmd.boundPoint.y);
                
                side = -side;
                serverId = 1 - serverId;
                
                if (Math.random() < 0.5) {
                    half = -half;
                }
            }
            
            if (Math.random() < 0.5) {
                var netPoint = getAndScaleRandomPointFrom(NET_POINTS, -half, side);
                pointAnimationFrames.push(
                    makeNetShot(NET_DURATION, 1-serverId, returnerPoint, shotPoint, netPoint));
                    
                gPointHint += " отбил мяч в сетку.";
            } else {
                var outPoint = getAndScaleRandomPointFrom(GAME_OUT_POINTS, -half, -side);
                pointAnimationFrames.push(
                    makeOutShot(OUT_DURATION, 1-serverId, returnerPoint, shotPoint, outPoint));
                gPointHint += " отбил мяч в аут.";
            }
            
            if (isBadFirstService) {
                gPointHint += (" При этом " + playerNameFor(serverId) + " один раз ошибся на подаче.");
            }
        }
        
        function getCurrentServerId() {
            return gScore.serverId();
        }
        
        function generatePointWonFor(winnerId) {
            hidePointHiht();
            
            var serverId = getCurrentServerId();
            if (winnerId != serverId) {
                if (Math.random() < 0.3) {
                    generateDoubleFaultFrames(serverId);
                    return;
                }
            }
            
            if (Math.random() < 0.5) {
                generateErrorFrames(serverId, winnerId);
            } else {
                generateWinnerFrames(serverId, winnerId);
            }
        }

        function viewPointHiht() {
            var hint = "";
            
            if (!gScore.isFight()) {
                if (gScore.isMatchWinner(0)) {
                    hint = playerNameFor(0) + " выиграл матч! ";
                } else if (gScore.isMatchWinner(1)) {
                    hint = playerNameFor(1) + " выиграл матч! ";
                }
            }
            
            mPointHint.innerHTML = ("* " + hint +  gPointHint);
        }
        
        function hidePointHiht() {
            gPointHint = "";
            
            var hint = "_";
            if (!gScore.isFight()) {
                if (gScore.isMatchWinner(0)) {
                    hint = playerNameFor(0) + " выиграл матч! ";
                } else if (gScore.isMatchWinner(1)) {
                    hint = playerNameFor(1) + " выиграл матч! ";
                }
            }
            
            mPointHint.innerHTML = hint;
        }
        
        function CScore(firstServerId) {
            this.SET_COUNT      = 5;
            this.TIEBREAK_SCORE = 6;
            
            this.firstServerId = firstServerId;
            this.currentSet    = 0;
            this.points        = [0,0];
            this.sets          = [[0,0],[0,0],[0,0],[0,0],[0,0]];
        }
        
        CScore.prototype.winPointBy = function(player) {
            if (!this.isFight()) {
                return;
            }

            this.points[player] += 1;
            this.updateScore();
        }

        CScore.prototype.winGameBy = function(player) {
            if (!this.isFight()) {
                return;
            }

            this.sets[this.currentSet][player] += 1;
            this.points = [0,0];
            this.updateScore();
        }

        CScore.prototype.winSetBy = function (player) {
            if (!this.isFight()) {
                return;
            }

            this.giveSetTo(player);
            this.updateScore();
        }

        CScore.prototype.giveSetTo = function (player) {
            this.points = [0,0];

            if (this.isTiebreak()) {
                this.sets[this.currentSet][player] += 1;
            } else {
                if ((this.sets[this.currentSet][1-player] - this.sets[this.currentSet][player]) >= 1) {
                    this.sets[this.currentSet][player] = this.sets[this.currentSet][1-player] + 1; 
                }
                
                if (this.sets[this.currentSet][player] <= 5) {
                    this.sets[this.currentSet][player] = 6;
                } else {
                    this.sets[this.currentSet][player] += 1;
                }
            }
        }
        
        CScore.prototype.isTiebreak = function () {
            if (!this.isFight()) {
                return false;
            }
            
            if (this.currentSet == 4) {
                return false;
            }
            
            return  (this.sets[this.currentSet][0] == this.TIEBREAK_SCORE) && 
                    (this.sets[this.currentSet][1] == this.TIEBREAK_SCORE);
        }

        CScore.prototype.isBreakpoint = function () {
            if ((!this.isFight()) || (this.isTiebreak())) {
                return false;
            }
            
            var player = this.serverId();
            return this.isBeforeWinGame(this.points[1 - player], this.points[player]); 
        }

        CScore.prototype.isSetpoint = function () {
            return this.isSetpointForPlayer(0) || this.isSetpointForPlayer(1);
        }
        
        CScore.prototype.isSetpointForPlayer = function (player) {
            if (!this.isFight()) {
                return false;
            }
            
            player = player;
            
            if (this.isTiebreak()) {
                return this.isTiebreakBeforeWinPoints(this.points[player], this.points[1-player]);
            }
            
            return  this.isBeforeWinSet(this.sets[this.currentSet][player], this.sets[this.currentSet][1-player]) && 
                    this.isBeforeWinGame(this.points[player], this.points[1-player]);
        }

        CScore.prototype.isMatchpoint = function () {
            if (!this.isFight()) {
                return false;
            }
            
            var s0 = 0;
            var s1 = 0;
            
            for (var i=0; i<this.currentSet; i++) {
                if (this.sets[i][0] > this.sets[i][1]) {
                    s0++;
                } else {
                    s1++;
                }
            }
            
            if ((s0 == 2) && (s1 == 2)) {
                return this.isSetpoint();
            } 
            
            if (s0 == 2) {
                return this.isSetpointForPlayer(0);
            } else if (s1 == 2) {
                return this.isSetpointForPlayer(1);
            }

            return false;
        }

        CScore.prototype.serverId = function () {
            if (!this.isFight()) {
                return 0;
            }
            
            var gameCount = 0;
            for (var i=0; i <= this.currentSet; i++) {
                gameCount += (this.sets[i][0] + this.sets[i][1]);
            }
        
            var serverId = (gameCount + this.firstServerId) % 2;
            if (this.isTiebreak()) {
                var playerId = 1;
                switch ((this.points[0] + this.points[1]) % 4) {
                    case 0:
                    case 3: playerId = 0; 
                }
                
                serverId = (serverId + playerId) % 2;
            } 
            
            return serverId;
        }

        CScore.prototype.serviceHalf = function () {
            if (this.isFight()) {
                if (this.isTiebreak()) {
                    switch ((this.points[0] + this.points[1]) % 4) {
                        case 0:
                        case 1:  return 1;
                        default: return -1;
                    }
                } else {
                    return 1-2*((this.points[0] + this.points[1]) % 2);
                }
            }
            return 0;
        }
        
        CScore.prototype.updateScore = function () {
            if (!this.isFight()) {
                return;
            }
            
            if (this.isTiebreak()) {
                if (this.isTiebreakWinPoints(this.points[0], this.points[1])) {
                    this.sets[this.currentSet][0] += 1;
                    this.points = [0,0];
                    this.currentSet += 1;
                } else if (this.isTiebreakWinPoints(this.points[1], this.points[0])) {
                    this.sets[this.currentSet][1] += 1;
                    this.points = [0,0];
                    this.currentSet += 1;
                }
            } else {
                if (this.isWinPoints(this.points[0], this.points[1])) {
                    this.sets[this.currentSet][0] += 1;
                    this.points = [0,0];
                } else if (this.isWinPoints(this.points[1], this.points[0])) {
                    this.sets[this.currentSet][1] += 1;
                    this.points = [0,0];
                }
            
                if (this.isWinGames(this.sets[this.currentSet][0], this.sets[this.currentSet][1], this.currentSet)
                 || this.isWinGames(this.sets[this.currentSet][1], this.sets[this.currentSet][0], this.currentSet)) {
                    
                    this.points = [0,0];
                    this.currentSet += 1;
                }
            }
        }

        CScore.prototype.wonSetsBy = function (player) {
            var s = 0;
            for (var i=0; i<this.currentSet; i++) {
                if (this.sets[i][player] > this.sets[i][1-player]) {
                    s++;
                } 
            }
            return s;
        }
        
        CScore.prototype.isMatchWinner = function (player) {
            return (this.wonSetsBy(player) >= 3);
        }
        
        CScore.prototype.isFight = function () {
            return (!this.isMatchWinner(0)) && (!this.isMatchWinner(1));
        }

        CScore.prototype.isWinPoints = function (p0,p1) {
            return (p0 > 3) && ((p0 - p1) >= 2);
        }

        CScore.prototype.isBeforeWinGame = function (p0,p1) {
            return (p0 >= 2) && ((p0 - p1) >= 1);
        }

        CScore.prototype.isTiebreakWinPoints = function (p0,p1) {
            return (p0 >= 7) && ((p0 - p1) >= 2);
        }

        CScore.prototype.isTiebreakBeforeWinPoints = function (p0,p1) {
            return (p0 >= 6) && ((p0 - p1) >= 1);
        }

        CScore.prototype.isWinGames = function (g0,g1,setIndex) {
            return ((g0 == 6) && ((g0 - g1) >= 2) || 
                   ((setIndex <  4) && (g0 >  6) && ((g0 - g1) > 0)) ||
                   ((setIndex >= 4) && (g0 >= 6) && ((g0 - g1) >= 2)));
        }

        CScore.prototype.isBeforeWinSet = function (g0,g1) {
            return (g0 >= 5) && ((g0 - g1) >= 1);
        }

        CScore.prototype.pointsStringFor = function(player) {
            player = player;
            
            if (this.isTiebreak()) {
                return this.points[player];
            }
            
            if (this.points[player] == 0) {
                return '0';
            } else if (this.points[player] == 1) {
                return '15';
            } else if (this.points[player] == 2) {
                return '30';
            } else if (this.points[player] == 3) {
                return '40';
            } else if (this.points[player] > 3) {
                if ((this.points[player] - this.points[1-player]) <= 0) {
                    return '40';
                } else if ((this.points[player] - this.points[1-player]) == 1) {
                    return 'Ad';
                }
            }
            
            return '?';
        }
        
        function onWinButtonClick() {
            if (!gScore.isFight()) {
                return;
            }
            
            gPointFor = 0;
            generatePointWonFor(0);
            allButtonsDisabledTo(true);
            startPointAnimation();
        }
        
        function onLooseButtonClick() {
            if (!gScore.isFight()) {
                return;
            }
            
            gPointFor = 1;
            generatePointWonFor(1);
            allButtonsDisabledTo(true);
            startPointAnimation();
        }

        function pointHihtAfterBifFight() {
            gPointHint = "";
            
            var hint = "Было сыграно несколько розыгрышей!";
            if (!gScore.isFight()) {
                if (gScore.isMatchWinner(0)) {
                    hint = "Шла упорная борьба, и " + playerNameFor(0) + " выиграл матч! ";
                } else if (gScore.isMatchWinner(1)) {
                    hint = "Шла упорная борьба, и " + playerNameFor(1) + " выиграл матч! ";
                }
            }
            
            mPointHint.innerHTML = hint;
        }
        
        function viewAfterBigFight() {
            viewScore();
            pointHihtAfterBifFight();
            if (gScore.isFight()) {
                movePlayersToBench();
            } else {
                movePlayersToNet();
            }
        }
        
        function onWinGameButtonClick() {
            gScore.winGameBy(0);

            viewAfterBigFight();
        }
        
        function onLooseGameButtonClick() {
            gScore.winGameBy(1);

            viewAfterBigFight();
        }
        
        function onWinSetButtonClick() {
            gScore.winSetBy(0);

            viewAfterBigFight();
        }
        
        function onLooseSetButtonClick() {
            gScore.winSetBy(1);

            viewAfterBigFight();
        }
        
        function onPlayAgain() {
            gScore = new CScore(0);

            viewScore();
            hidePointHiht();
            movePlayersToNet();
        }
       
        function allButtonsDisabledTo(value) {
            mLooseSet0Btn.disabled = value;
            mLooseSet1Btn.disabled = value;
            mLooseGame0Btn.disabled = value;
            mLooseGame1Btn.disabled = value;
            mLoosePoint0Btn.disabled = value;
            mLoosePoint1Btn.disabled = value;
        }
        
        function viewTvScore() {
            var setIndex = 0;
            var setScore;
            for (; setIndex < gScore.currentSet; setIndex++) {
                setScore = window.document.getElementById("mTvSet0" + setIndex);
                setScore.innerHTML = gScore.sets[setIndex][0];
                setScore.style.display = 'block';
                
                setScore = window.document.getElementById("mTvSet1" + setIndex);
                setScore.innerHTML = gScore.sets[setIndex][1];
                setScore.style.display = 'block';
            }
            
            if (gScore.isFight()) {
                setScore = window.document.getElementById("mTvSet0" + setIndex);
                setScore.innerHTML = gScore.sets[setIndex][0];
                setScore.style.display = 'block';
                
                setScore = window.document.getElementById("mTvSet1" + setIndex);
                setScore.innerHTML = gScore.sets[setIndex][1];
                setScore.style.display = 'block';
            }

            for (setIndex++; setIndex < 5; setIndex++) {
                setScore = window.document.getElementById("mTvSet0" + setIndex);
                setScore.style.display = 'none';
                
                setScore = window.document.getElementById("mTvSet1" + setIndex);
                setScore.style.display = 'none';
            }
            
            window.document.getElementById("mTvPoint0").innerHTML = gScore.pointsStringFor(0);
            window.document.getElementById("mTvPoint1").innerHTML = gScore.pointsStringFor(1);
            
            mTvMatchpiont.style.display = 'none';
            mTvSetpoint.style.display = 'none';
            mTvBreakpoint.style.display = 'none';
            mTvTiebreak.style.display = 'none';
            
            if (gScore.isMatchpoint()) {
                mTvMatchpiont.style.display = 'block';
            } else if (gScore.isSetpoint()) {
                mTvSetpoint.style.display = 'block';
            } else if (gScore.isBreakpoint()) {
                mTvBreakpoint.style.display = 'block';
            } else if (gScore.isTiebreak()) {
                mTvTiebreak.style.display = 'block';
            }
            
            window.document.getElementById("mBigSbServiceMark" + gScore.serverId()).style.display = 
                gScore.isFight() ? 'block' : 'none';
            window.document.getElementById("mBigSbServiceMark" + (1-gScore.serverId())).style.display = 'none';
        }
        
        function viewBigSbScore() {
            var setIndex = 0;
            var setScore;
            var previousSetCount = gScore.isFight() ? gScore.currentSet : (gScore.currentSet - 1)
            for (; setIndex < previousSetCount; setIndex++) {
                setScore = window.document.getElementById("mBigSbSet0" + setIndex);
                setScore.innerHTML = gScore.sets[setIndex][0];
                
                setScore = window.document.getElementById("mBigSbSet1" + setIndex);
                setScore.innerHTML = gScore.sets[setIndex][1];
            }
            
            mBigSbGames0.innerHTML = gScore.sets[setIndex][0];
            mBigSbGames1.innerHTML = gScore.sets[setIndex][1];
            
            for (; setIndex < 4; setIndex++) {
                setScore = window.document.getElementById("mBigSbSet0" + setIndex);
                setScore.innerHTML = "_";
                
                setScore = window.document.getElementById("mBigSbSet1" + setIndex);
                setScore.innerHTML = "_";
            }
            
            mBigSbPoints0.innerHTML = gScore.pointsStringFor(0);
            mBigSbPoints1.innerHTML = gScore.pointsStringFor(1);
            
            mBigSbSets0.innerHTML = gScore.wonSetsBy(0);
            mBigSbSets1.innerHTML = gScore.wonSetsBy(1);
            
            window.document.getElementById("mTvServiceMark" + gScore.serverId()).style.display = 
                gScore.isFight() ? 'block' : 'none';
            window.document.getElementById("mTvServiceMark" + (1-gScore.serverId())).style.display = 'none';
        }
        
        function viewScore() {
            viewTvScore();
            viewBigSbScore();
        }
        
        initCourt();
        viewScore();
    </script>
</body>
</html>